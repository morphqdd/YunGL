use "utils/viewMatrix";
use "utils/projectionMatrix";

export class Cube {
    init(camera, light) {
        let vertexShader = "
            #version 330 core

            in vec4 position;
            in vec3 normal;

            uniform mat4 model;
            uniform mat4 view;
            uniform mat4 projection;

            out vec3 v_world_pos;
            out vec3 v_world_normal;

            void main() {

                vec4 world_pos   = model * position;
                v_world_pos      = world_pos.xyz;
                v_world_normal   = mat3(transpose(inverse(model))) * normal;


                gl_Position      = projection * view * world_pos;
            }
        ";

        let fragmentShader = "
            #version 330 core

            in  vec3 v_world_pos;
            in  vec3 v_world_normal;

            uniform vec3 u_light;
            uniform vec3 u_view_pos;
            uniform vec3 u_light_color;
            uniform vec3 color;
            uniform float specular_strength;
            uniform float shininess;

            out vec4 out_color;

            void main() {
                vec3 N = normalize(v_world_normal);


                vec3 L = normalize(u_light - v_world_pos);


                vec3 ambient  = 0.1 * u_light_color;
                float diff    = max(dot(N, L), 0.0);
                vec3 diffuse  = diff * u_light_color;

                vec3 V        = normalize(u_view_pos - v_world_pos);
                vec3 H        = normalize(L + V);
                float spec    = pow(max(dot(N, H), 0.0), shininess);
                vec3 specular = specular_strength * spec * u_light_color;

                vec3 result   = (ambient + diffuse + specular) * color;
                out_color     = vec4(result, 1.0);
            }
        ";


        print "Fragment" + fragmentShader;
        let dimensions = getWindowDimensions();
        let projectionM = projectionMatrix(dimensions.width, dimensions.height);

        self.light = light;
        self.camera = camera;

        self.pipeline = {
            vertex: vertexShader,
            fragment: fragmentShader,
            attributes: {
                in: {
                    position: "vec4",
                    normal: "vec3"
                },
                out: {
                    v_normal: "vec3",
                    v_position: "vec3",
                    v_world_pos: "vec3",
                    v_world_normal: "vec3"
                }
            },
            uniform: {
                    model: { type: "mat4", value: self._makeModel(0) },
                    view: { type: "mat4", value: camera.getViewMatrix() },
                    projection: { type: "mat4", value: projectionM },
                    color: { type: "vec3", value: [1, 1, 1] },
                    u_light: { type: "vec3", value: light },
                    u_light_color: { type: "vec3", value: [1, 1, 1] },
                    u_view_pos: { type: "vec3", value: camera.position },
                    specular_strength: { type: "float", value: 0.5 },
                    shininess: { type: "float", value: 32.0 }
                },
            primitive: "triangles"
        };

        self.vertices = {
                    data: [
                        { x:-0.5, y:-0.5, z: 0.5, nx: 0, ny: 0, nz: 1 },
                        { x: 0.5, y:-0.5, z: 0.5, nx: 0, ny: 0, nz: 1 },
                        { x: 0.5, y: 0.5, z: 0.5, nx: 0, ny: 0, nz: 1 },
                        { x:-0.5, y:-0.5, z: 0.5, nx: 0, ny: 0, nz: 1 },
                        { x: 0.5, y: 0.5, z: 0.5, nx: 0, ny: 0, nz: 1 },
                        { x:-0.5, y: 0.5, z: 0.5, nx: 0, ny: 0, nz: 1 },

                        { x: 0.5, y:-0.5, z:-0.5, nx: 0, ny: 0, nz:-1 },
                        { x:-0.5, y:-0.5, z:-0.5, nx: 0, ny: 0, nz:-1 },
                        { x:-0.5, y: 0.5, z:-0.5, nx: 0, ny: 0, nz:-1 },
                        { x: 0.5, y:-0.5, z:-0.5, nx: 0, ny: 0, nz:-1 },
                        { x:-0.5, y: 0.5, z:-0.5, nx: 0, ny: 0, nz:-1 },
                        { x: 0.5, y: 0.5, z:-0.5, nx: 0, ny: 0, nz:-1 },

                        { x: 0.5, y:-0.5, z: 0.5, nx: 1, ny: 0, nz: 0 },
                        { x: 0.5, y:-0.5, z:-0.5, nx: 1, ny: 0, nz: 0 },
                        { x: 0.5, y: 0.5, z:-0.5, nx: 1, ny: 0, nz: 0 },
                        { x: 0.5, y:-0.5, z: 0.5, nx: 1, ny: 0, nz: 0 },
                        { x: 0.5, y: 0.5, z:-0.5, nx: 1, ny: 0, nz: 0 },
                        { x: 0.5, y: 0.5, z: 0.5, nx: 1, ny: 0, nz: 0 },

                        { x:-0.5, y:-0.5, z:-0.5, nx:-1, ny: 0, nz: 0 },
                        { x:-0.5, y:-0.5, z: 0.5, nx:-1, ny: 0, nz: 0 },
                        { x:-0.5, y: 0.5, z: 0.5, nx:-1, ny: 0, nz: 0 },
                        { x:-0.5, y:-0.5, z:-0.5, nx:-1, ny: 0, nz: 0 },
                        { x:-0.5, y: 0.5, z: 0.5, nx:-1, ny: 0, nz: 0 },
                        { x:-0.5, y: 0.5, z:-0.5, nx:-1, ny: 0, nz: 0 },

                        { x:-0.5, y: 0.5, z: 0.5, nx: 0, ny: 1, nz: 0 },
                        { x: 0.5, y: 0.5, z: 0.5, nx: 0, ny: 1, nz: 0 },
                        { x: 0.5, y: 0.5, z:-0.5, nx: 0, ny: 1, nz: 0 },
                        { x:-0.5, y: 0.5, z: 0.5, nx: 0, ny: 1, nz: 0 },
                        { x: 0.5, y: 0.5, z:-0.5, nx: 0, ny: 1, nz: 0 },
                        { x:-0.5, y: 0.5, z:-0.5, nx: 0, ny: 1, nz: 0 },

                        { x:-0.5, y:-0.5, z:-0.5, nx: 0, ny:-1, nz: 0 },
                        { x: 0.5, y:-0.5, z:-0.5, nx: 0, ny:-1, nz: 0 },
                        { x: 0.5, y:-0.5, z: 0.5, nx: 0, ny:-1, nz: 0 },
                        { x:-0.5, y:-0.5, z:-0.5, nx: 0, ny:-1, nz: 0 },
                        { x: 0.5, y:-0.5, z: 0.5, nx: 0, ny:-1, nz: 0 },
                        { x:-0.5, y:-0.5, z: 0.5, nx: 0, ny:-1, nz: 0 }
                    ],
                    layout: ["vec3", "normal"]
                };
    }

    _makeModel(t) {

        return [
            [1, 0, 0, 0],
            [0, 1, 0, 0],
            [0, 0, 1, 0],
            [0, 0, 0, 1]
          ];
    }

    update(dt) {

        self.pipeline.uniform.model.value = self._makeModel(dt);
        self.pipeline.uniform.view.value = self.camera.getViewMatrix();

        let dimensions = getWindowDimensions();
        self.pipeline.uniform.projection.value = projectionMatrix(dimensions.width, dimensions.height);
        self.pipeline.uniform.u_view_pos.value = self.camera.position;

        self.pipeline.uniform.u_light.value = self.light;
    }

    getPipeline() {
        return self.pipeline;
    }

    getVertices() {
        return self.vertices;
    }
}
